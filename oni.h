#ifndef ONI
#define ONI

//! @file   oni.h
//! @brief  oni - проект "Онегин", программа для сортировки строк текста по прямому и обратному лексикографическому признаку

#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#include <ctype.h>
#include <assert.h>

//! @brief  Набор констант, используемых для обозначения результата выполнения (успех или ошибка) функции open_in_out_files ()

enum FILE_OPEN_SUCCESS {FILE_OPENED_FULL_AUTO = 0, FILE_OPENED_AUTO_OUTPUT = 1, FILE_OPENED_MANUALLY = 2, OPEN_FAILED = -1};

//! @brief  Набор констант, используемых для обозначения результата выполнения (успех или ошибка) функции BUFFERprint_text ()

enum BUFF_PRINT_SUCCESS {TEXT_PRINTED = 0, PRINT_FAILED = -1};

//! @brief  Константа, необходимая для наглядности вызова функции fseek (обозначающая нулевой отступ от указанной в последнем параметре позиции)

constexpr long NO_OFFSET = 0;

//! @brief  Структура, содержащая указатель на первый элемент строки текста, записанной в буфер - ptr, и размер этой строки в символах (ИСКЛЮЧАЯ завершающий строку '\n') - linesize
//!
//! @note   Неучет завершающего строку '\n' при подсчете количества символов позволяет избежать дополнительных затрат на пропуск несравниваемых символов (в т.ч. '\n') при сравнении строк в функциях-компораторах (см. line_compar () и REVline_compar ()), однако немного замедляет вывод отсортированного текста через таблицу индексации (из-за необходимости добавлять 1 к linesize перед печатью - см. INDEXprint_text ())

struct line_index_t {

    const char* ptr;
    int linesize;
};

//! @brief  Функция, позволяющая узнать размер символов в исходном тексте, хранимом в файле
//!
//! @param  file_in     Указатель на файл с исходным текстом
//!
//! @return Количество символов в исходном тексте (включая служебные)

size_t get_file_size (FILE* const file_in);

//! @brief  Функция, отвечающая за формирования буфера, в который будет помещен исходный текст из файла, и перенос этого текста в буфер
//!
//! @param  file_in     Указатель на файл с исходным текстом
//! @param  filesize    Размер исходного текста из файла в символах (с учетом служебных)
//!
//! @return Указатель на первую ячейку буфера
//!
//! @note   Во избежание фрагментации памяти функция формирует один непрерывный буфер (динамический char-массив), начинающийся с первого символа первой строки исходного текста, и заканчивающийся символом '\0', обозначающим конец буфера и фактически делающий его одной сплошной строкой C
//!
//! @warning   В процессе выполнения дальнейшей программы крайне нежелательно видоизменять какие-либо данные, хранящиеся в буфере, т.к. тогда будет потеряна возможность вывода исходной версии текста (исключение составляет нормализация буфера - см. normalize_buffer ())

char* init_buffer (FILE* const file_in, const size_t filesize);

//! @brief  Функция, позволяющая узнать количество строк в исходном тексте
//!
//! @param  buffer  Указатель на первую ячейку буфера, в котором хранится текст (см. init_buffer())
//!
//! @return Количество строк в исходном тексте (включая пустые)
//!
//! @warning    Для корректной работы этой функции (и всех функций, использующих ее результат, а также функции-инициализатора таблицы индексации буфера - см. init_index_tbl ()) необходимо, чтобы КАЖДАЯ строка текста (включая последнюю) завершалась переходом на следующую строку

int get_num_of_lines (const char* const buffer);

//! @brief  Функция, отвечающая за формирование таблицы индексации буфера, хранящей в себе (в виде переменных типа line_index) информацию о каждой из строк текста (указатель на первый символ и размер)
//!
//! @param  buffer      Указатель на первую ячейку буфера, в котором хранится текст
//! @param  numoflines  Количество строк в исходном тексте (включая пустые)
//!
//! @return Указатель на первую ячейку таблицы индексации
//!
//! @note   Функция также удаляет из текста идущие подряд "пустые" символы (табуляция, пробел и т.д. - кроме перехода на новую строку), заменяя их на одиночные, удаляет "пустые" символы в начале и в конце каждой строки
//! @note   Функция работает за один проход буфера с текстом, не выделяя дополнительную память

line_index_t* init_index_tbl (char* buffer, const int numoflines);

//! @brief  Функция, отвечающая за последовательный вывод в файл строк, информация о которых хранится в таблице индексации (см. init_index_tbl ()), с сохранением порядка ЯЧЕЕК ТАБЛИЦЫ
//!
//! @param  file_out    Указатель на файл, в который производится вывод
//! @param  indextbl    Указатель на первую ячейку таблицы индексации, с использованием которой производится вывод
//! @param  numoflines  Количество строк в исходном (т.е. и в выводимом) тексте с учетом пустых
//!
//! @return Количество напечатанных в файл строк (в случае успеха значение совпадает со значением numoflines)

int INDEXprint_text (FILE* const file_out, const line_index_t* const indextbl, const int numoflines);

//! @brief  Функция, отвечающая за вывод в файл содержимого буфера (т.е. в нормальном случае либо исходного текста, либо его нормализованной версии)
//!
//! @param  file_out    Указатель на файл, в который производится вывод
//! @param  buffer  Указатель на первую ячейку буфера, в котором хранится текст
//!
//! @return Константа из набора enum BUFF_PRINT_SUCCESS - FILE_PRINTED, если вывод удался; PRINT_FAILED, если возникла ошибка

int BUFFERprint_text (FILE* const file_out, const char* const buffer);

//! @brief  Функция, отвечающая за освобождение всей динамической памяти, занятой в процессе работы программы
//!
//! @param  tbl     Указатель на первую ячейку таблицы, хранящей значения типа line_index_t (таблицы индексации), памать из под которой освобождается
//! @param  buffer  Указатель на первый элемент буфера, хранящего значения типа char, память из под которого освобождается

void clean_memory (line_index_t* tbl, char* buffer);

//! @brief  Компоратор, сравнивающий две строки (точнее, два упорядоченных набора символов заданной длины, не обязательно заканчивающегося нуль-байтом) в обратном лексико-графическом порядке (С КОНЦА строк)
//!
//! @param  line1   Элемент структурного типа данных line_index, характеризующий первую сравниваемую строку
//! @param  line2   Элемент структурного типа данных line_index, характеризующий вторую сравниваемую строку
//!
//! @return Результат сравнения - число меньше нуля, если первая строка должна идти раньше второй; число больше нуля, если должна идти позже; ноль, если строки эквивалентны в лексикографическом смысле
//!
//! @note   Функция при сравнении игнорирует знаки, не относящиеся к буквам - цифры, знаки препинания и т.д.
//!
//! @warning    Функция гарантированно корректно работает только со строками, включающими буквы английского алфавита; поведение программы при попытке обработать символы иных алфавитов не определено

int REVline_compar (const void* line1, const void* line2);

//! @brief  Компоратор, сравнивающий две строки (точнее, два упорядоченных набора символов заданной длины, не обязательно заканчивающегося нуль-байтом) в прямом лексико-графическом порядке (С НАЧАЛА строк)
//!
//! @param  line1   Элемент структурного типа данных line_index, характеризующий первую сравниваемую строку
//! @param  line2   Элемент структурного типа данных line_index, характеризующий вторую сравниваемую строку
//!
//! @return Результат сравнения - число меньше нуля, если первая строка должна идти раньше второй; число больше нуля, если должна идти позже; ноль, если строки эквивалентны в лексикографическом смысле
//!
//! @note   Функция при сравнении игнорирует знаки, не относящиеся к буквам - цифры, знаки препинания и т.д.
//!
//! @warning    Функция гарантированно корректно работает только со строками, включающими буквы английского алфавита; поведение программы при попытке обработать символы иных алфавитов не определено

int line_compar (const void* line1, const void* line2);

//! @brief  Компоратор, производящий лексикографическое сравнение двух символов
//!
//! @param  symb1   Первый символ, подлежащий сравнению
//! @param  symb2   Второй символ, подлежащий сравнению
//!
//! @return Результат сравнения - число меньше нуля, если первый символ в алфавите идет раньше второго; число больше нуля, если позже; ноль, если символы обозначают одинковые буквы
//!
//! @note   Функция при сравнении игнорирует регистр буквенных символов
//!
//! @warning    Функция предназначена для сравнения буквенных символов, относящихся к английскому алфавиту; поведение программы при попытке обработать небуквенный символ или буквенный символ не английского алфавита не определено

int symb_compar (char symb1, char symb2);

//! @brief  Функция сортировки методом пузырька
//!
//! @param  arr     Указатель на первый элемент массива из элементов произвольного типа
//! @param  nmemb   Количество элементов в сортируемом массиве
//! @param  size    Размер типа данных, к которому относятся элементы сортируемого массива, в байтах
//! @param  compar  Функция-компоратор элементов массива

void bubble_sort (void* arr, size_t nmemb, int size, int (*compar) (const void*, const void*));

//! @brief  Функция сортировки методом слияния
//!
//! @param  arr     Указатель на первый элемент массива из элементов произвольного типа
//! @param  nmemb   Количество элементов в сортируемом массиве
//! @param  size    Размер типа данных, к которому относятся элементы сортируемого массива, в байтах
//! @param  compar  Функция-компоратор элементов массива

void merge_sort (void* arr, size_t nmemb, int size, int (*compar) (const void*, const void*));

//! @brief  Функция нахождения минимума из двух целых чисел типа int
//!
//! @param  val1    Первое число из пары, минимум в которой нужно найти
//! @param  val2    Второе число из пары, минимум в которой нужно найти
//!
//! @return Целое число типа int, равное минимуму из двух чисел-параметров функции

int dmin (int val1, int val2);

//! @brief  Функция нахождения максимума из двух целых чисел типа int
//!
//! @param  val1    Первое число из пары, максимум в которой нужно найти
//! @param  val2    Второе число из пары, максимум в которой нужно найти
//!
//! @return Целое число типа int, равное максимуму из двух чисел-параметров функции

int dmax (int val1, int val2);

//! @brief  Функция побайтового обмена значениями двух переменных произвольного типа
//!
//! @param  data_ptr1   Указатель на первую ячейку памяти из выделенных для хранения значения первой переменной произвольного типа
//! @param  data_ptr2   Указатель на первую ячейку памяти из выделенных для хранения значения второй переменной произвольного типа
//! @param  size        Размер типа данных, к которому относятся переменные, в байтах

void swap_by_byte (void* data_ptr1, void* data_ptr2, int size);

//! @brief  Функцция побайтового присвоения одной переменной произвольного типа значения другой переменной произвольного типа
//!
//! @param  dest_ptr    Указатель на первую ячейку памяти из выделенных для хранения значения переменной произвольного типа, которой присваивается новое значение
//! @param  src_ptr     Указатель на первую ячейку памяти из выделенных для хранения значения переменной произвольного типа, значение которой присваивается другой переменной
//! @param  size        Размер типа данных, к которому относятся переменные, в байтах

void copy_by_byte (void* dest_ptr, void* src_ptr, int size);

//! @brief  Функция, отвечающая за открытие файлов для чтения и записи текста
//!
//! @param  file_in     Указатель на указатель на файл, используемый для ввода текста в программу
//! @param  file_out    Указатель на указатель на файл, используемый для вывода текста из программы
//! @param  argc        Количество аргументов, принятых из командной строки при запуске программы (включая полное имя программы)
//! @param  argv        Указатель на первую ячейку массива из строк, хранящего все аргументы, приятые из командной строки при запуске программы
//!
//! @note   Функция позволяет обработать ноль, один или два доп. параметра, переданных программе через командную строку в качестве названий файлов для ввода и вывода, (см. return), причем если в командную строку не поступило названий файлов для ввода/вывода и ввод/вывод производится из файлов по умолчанию (oni_input.txt для ввода и oni_output.txt для вывода); если в командную строку поступило только одно название файла, оно будет воспринятно как название файла ввода, вывод будет производиться в файл по умолчанию; если в командную строку постпили названия обоих файлов, первый из них будет использован для ввода, второй - для вывода
//!
//! @return Константа из набора enum FILE_OPEN_SUCCESS - FILE_OPENED_FULL_AUTO, если в командную строку не поступило названий файлов для ввода/вывода И открытие прошло успешно; FILE_OPENED_AUTO_OUTPUT - если в командную строку поступило только одно название файла И открытие прошло успешно; FILE_OPENED_MANUALLY - если в командную строку постпили названия обоих файлов И открытие прошло успешно; OPEN_FAILED - если при отркытии возникла ошибка

int open_in_out_files (FILE** file_in, FILE** file_out, int argc, char** argv);

#endif